[<- К содержанию](readme.md)

### 3.2 Основы ветвления и слияния

Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в вашем проекте. Ваша работа построена так:

1. Вы работаете над сайтом.
2. Вы создаете ветку для новой статьи, которую вы пишете.
3. Вы работаете в этой ветке.

В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая скорейшего исправления. Ваши действия:

1. Переключиться на основную ветку.
2. Создать ветку для добавления исправления.
3. После тестирования слить ветку содержащую исправление с основной веткой.
4. Переключиться назад в ту ветку, где вы пишете статью и продолжить работать.

#### Основы ветвления

Предположим, вы работаете над проектом и уже имеете несколько коммитов.

![одна ветка мастер](basic-branching-1.png)

Чтобы решить какую-то проблему, протестировать и внести изменения в общий репозиторий создаем ветку, например под названием `iss53`  и сразу переключаемся на нее:

```git chekout -b <iss53>```

Создастся указатель для новой ветки:

![новый указатель iss53](basic-branching-2.png)

По мере добавления коммитов, ветка iss53 движется вперед и HEAD указывает на нее:

![Ветка iss53 двигается вперед](basic-branching-3.png)

Чтобы вернуться к предыдущей работе, надо просто переключиться на ветку `master`. Только сначала необходимо закоммитить изменения в ветке `iss53`, чтобы небыло конфликтов.

`git sheckout master` переключит на ветку мастер.
Мы увидим тот же каталог на момент коммита в ветке мастер.

Для изменений в предцдущей работе создадим новую ветку от ветки мастер и перейдем в нее:

`git checkout -b hotfix`

Сделаем исправление и закоммитим:

`git commit -a -m 'Fix broken email address'`

Ветки примут такой вид:

![Ветка hotfix основана на ветке master](basic-branching-4.png)

Если тесты прошли благополучно можно выполнить слияние ветки `hotfix` с веткой `master` для включения изменений.

`git checkout master` переключит на ветку `maste`r.

`git merge hotfix` сольет изменения в ветке `hotfix` с веткой `master`.

Вывод будет выглядеть так:

```
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
 ```

 `Fast-forward` в выводе после команды `git merge` означает что Git просто переместил указатель ветки вперед, потому что коммит C4, на который указывает слитая ветка `hotfix`, был прямым потомком коммита C2, на котором вы находились до этого. Другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях. Это называется «fast-forward».

 Теперь ветки выглядят так:

 ![master перемотан до hotfix](basic-branching-5.png)

 Ветку notfix можно удалить - ветка master указывает на то же самое место.

 `git branch -d notfix` Удалит ветку notfix.

 Дальше можно продолжить работу в ветке `iss53`

 ```
 $ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'Finish the new footer [issue 53]'
[iss53 ad82d7a] Finish the new footer [issue 53]
1 file changed, 1 insertion(+)
```

Теперь ветки выгдядят так:

![Продолжение работы над iss53](basic-branching-6.png)

Если изменения из `notfix` надо включить в `iss53`, то можно влить ветку `master` в ветку `iss53` командой `git merge master`.

Либо после завершения работы в ветке `iss53`, слить ее с веткой `master`.

#### Основы слияния

Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master. Для этого нужно выполнить слияние ветки `iss53` точно так же, как вы делали это с веткой `hotfix` ранее. Все, что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду `git merge`:

```
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
```
В этом случае Git выполняет простое трёхстороннее слияние, используя последние коммиты объединяемых веток и общего для них родительского коммита:

![Использование трёх снимков при слиянии](basic-merging-1.png)

Вместо того, чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый результирующий снимок трёхстороннего слияния, а затем автоматически делает коммит. Этот особый коммит называют коммитом слияния, так как у него более одного предка:

![Коммит слияния](basic-merging-2.png)

Теперь, когда изменения слиты, ветка iss53 больше не нужна можно удалить ветку:

`git branch -d iss53`

#### Основные конфликты слияния

Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить. Если ваше исправление ошибки #53 потребовало изменить ту же часть файла что и hotfix, вы получите примерно такое сообщение о конфликте слияния:

```
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
```
 Чтобы в любой момент после появления конфликта увидеть, какие файлы не объединены, вы можете запустить `git status`:

 ```
 $ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
```

Всё, где есть неразрешённые конфликты слияния, перечисляется как неслитое. В конфликтующие файлы Git добавляет специальные маркеры конфликтов, чтобы вы могли исправить их вручную. В вашем файле появился раздел, выглядящий примерно так:

```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```
Это означает, что версия из `HEAD` (вашей ветки `master`, поскольку именно её вы извлекли перед запуском команды слияния) — это верхняя часть блока (всё, что над =======), а версия из вашей ветки `iss53` представлена в нижней части. Чтобы разрешить конфликт, придётся выбрать один из вариантов, либо объединить содержимое по-своему. Например, вы можете разрешить конфликт, заменив весь блок следующим:

```
<div id="footer">
please contact us at email.support@github.com
</div>
```

В этом разрешении есть немного от каждой части, а строки <<<<<<<, ======= и >>>>>>> полностью удалены. Разрешив каждый конфликт во всех файлах, запустите git add для каждого файла, чтобы отметить конфликт как решённый. Добавление файла в индекс означает для Git, что все конфликты в нём исправлены.

Если вы хотите использовать графический инструмент для разрешения конфликтов, можно запустить `git mergetool`.

После выхода из инструмента слияния Git спросит об успешности процесса. Если вы ответите скрипту утвердительно, то он добавит файл в индекс, чтобы отметить его как разрешенный. Теперь можно снова запустить git status, чтобы убедиться в отсутствии конфликтов:

```
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
```
Если это вас устраивает и вы убедились, что все файлы, где были конфликты, добавлены в индекс — выполните команду `git commit` для создания коммита слияния. Комментарий к коммиту слияния по умолчанию выглядит примерно так:

```
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
```

Если вы считаете, что коммит слияния требует дополнительных пояснений — опишите как были разрешены конфликты и почему были применены именно такие изменения, если это не очевидно.

[<- Назад](branching.md)

[Вперед ->](branch-management.md)
